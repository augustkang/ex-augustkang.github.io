[{"categories":["book"],"content":"2020년에 읽은 책들을 나열하는 포스트(업데이트중) 2020-01-01 고래(천명관) 2020-01-04 페인트(이희영) 2020-03-31 가만한 나날(김세희) 2020-04-01 일의 기쁨과 슬픔(장류진) 2020-04-03 해가 지는 곳으로(최진영) 2020-04-04 우리가 빛의 속도로 갈 수 없다면(김초엽) 2020-04-07 시라노(Edmond Rostand) 2020-04-11 사진을 읽어 드립니다(김경훈) 2020-04-13 동물농장(George Orwell) 2020-04-21 나목 도둑맞은 가난(박완서) 2020-04-24 콜센터(김의경) 2020-04-26 DevOps와 SE를 위한 리눅스 커널 이야기(강진우) 2020-04-27 체리새우: 비밀글입니다(황영미) 2020-04-28 템페스트(William Shakespeare) 2020-05-08 피닉스 프로젝트(Gene Kim, Kevin Behr, George Spafford) 2020-05-14 사서함 110호의 우편물(이도우) 2020-05-21 리추얼(Mason Currey) 2020-05-26 9번의 일(김혜진) 2020-05-30 문장 수집 생활(이유미) 2020-06-02 3기니(Virginia Woolf) 2020-06-08 달리기를 말할 때 내가 하고 싶은 이야기(무라카미 하루키) 2020-06-10 누구(아사이 료) 2020-06-14 광대하고 게으르게(문소영) 2020-06-17 오늘의 엄마(강진아) 2020-06-21 변신 시골의사(Franz Kafka) 2020-06-25 위대한 개츠비(F. Scott Fitzgerald) 2020-06-29 꾸뻬씨의 행복여행(François Lelord) 2020-07-09 자존가들(김지수) 2020-07-13 웹 엔지니어가 알아야 할 인프라의 기본(바바 토시아키) 2020-07-26 인생의 발견(Theodore Zeldin) 2020-07-29 나는 LINE 개발자입니다(강윤신, 김영환, 김재석, …) 2020-08-02 나는 아마존에서 미래를 다녔다(박정준) 2020-08-07 보통의 언어들(김이나) 2020-08-13 모두 거짓말을 한다(Seth Stephens-Davidowitz) 2020-08-21 글자풍경(유지원) 2020-08-29 노르웨이의 숲(무라카미 하루키) 2020-08-31 두 방문객(김희진) 2020-09-05 쇼룸(김의경) ","date":"2020-01-04","objectID":"/2020/2020-books-i-read/:0:0","tags":null,"title":"2020 Books I Read","uri":"/2020/2020-books-i-read/"},{"categories":["book","linux"],"content":"4장 - free 명령이 숨기고 있는 것들 ","date":"2019-07-17","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch4/:0:0","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 4장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch4/"},{"categories":["book","linux"],"content":"메모리 사용량 확인하기 root@August-PC:~# free -m total used free shared buff/cache available Mem: 8047 6161 1662 17 223 1755 Swap: 24576 214 24361 # 출력 데이터 단위에 따라 옵션이 다르다. # -b: byte 단위, -k: KB 단위, -m: MB 단위, -G: GB 단위 total : 전체, used : 사용중, free : 사용 안하고 있는 남는 용량 buff/cache : buffers와 cache 영역에서 차지하는 용량을 보여줌 Swap : swap 영역에 대한 내용. 전체, 사용중인 용량, 남는 용량 ","date":"2019-07-17","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch4/:0:1","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 4장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch4/"},{"categories":["book","linux"],"content":"buffers와 cached 영역 buffers 영역은 buffer cache 영역을 뜻함. super block, inode block 과 같이 파일의 내용이 아닌 파일시스템 관리에 필요한 메타데이터들을 위한 cache cached 영역은 page cache 영역을 뜻함. 파일 자체의 내용을 저장하는데 쓰이는 cache ","date":"2019-07-17","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch4/:0:2","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 4장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch4/"},{"categories":["book","linux"],"content":"/proc/meminfo 읽기 [root@August-PC ~]# cat /proc/meminfo MemTotal: 7957324 kB MemFree: 299176 kB MemAvailable: 4854520 kB Buffers: 141072 kB Cached: 4768400 kB SwapCached: 75588 kB Active: 4118228 kB Inactive: 2813128 kB Active(anon): 1330700 kB Inactive(anon): 1069180 kB Active(file): 2787528 kB Inactive(file): 1743948 kB Unevictable: 0 kB Mlocked: 0 kB SwapTotal: 8388604 kB SwapFree: 7214696 kB Dirty: 136 kB ... 생략 SwapCached: swap으로 사용된 영역 중 다시 메모리로 돌아온 영역. Swap으로 빠졌다고 돌아온 영역이 얼마나 되는지 나타냄. Active(anon): Page Cache 영역을 제외한 메모리 영역을 의미. 주로 프로세스들이 사용하는 메모리 영역 지칭. 그 중에서도 최근에 참조된(active) 영역 나타낸다. Active는 최근에 접근된 이력이 있는 영역이라는 뜻. Inactive(anon): 참조된 지 오래되어 Swap영역으로 이동할 수도 있는 메모리 영역. Inactive는 말 그대로 active 하지 않은, 접근된지 오래된, 최근에는 접근하지 않은 영역.. Active(file): 커널이 I/O 성능 향상을 위해 캐시 목적으로 사용하는 영역. buffer cache, page cache 영역이 여기에 속함. 그 중에서도 자주 접근된 영역 Inactive(file): 마찬가지로 커널이 캐시 목적으로 사용하는 영역 중에서도 접근한지 오래된 영역. Dirty: Active(file), Inactive(file)과 비슷한 용도로 I/O 성능 향상을 위해 커널이 캐시 목적으로 사용하는 영역 중 작업이 이루어져서 실제 블록 디바이스의 블록에 씌어져야 할 영역을 의미. 즉 디스크 쓰기 이후 commit이 이루어져야 하는 영역. 보통 block device에 write하면 block device write 연산은 메모리에 쓰는 것 보다 굉장히 latency가 크기 때문에(데이터 쓰는데 오래 걸리기 때문에) 그걸 끝날때까지 기다리기 보단 바로바로 처리 안하고 처리하기로 해놓고 나중에, 미래에 시스템에 여유가 있을때 실질적인 쓰기를 처리 하게 하는데 이 실질적으로 처리가 되어야 하는 영역을 의미. /fs/proc/meminfo.c 파일에서 active와 inactive를 구분하는 기준을 확인할 수 있다. LRU 기반의 리스트로 관리. 단순히 시간을 기반으로 시간이 지나 오래된 것, 최신의 것으로 나누지는 않음. vm.min_free_kbytes 커널 파라미터보다 여유 메모리 공간이 적게 될 경우 kswapd가 실행되면서 active 영역 페이지 중 오래된 페이지를 우선적으로 inactive로 옮긴 후 메모리를 해제(free)하는 작업을 수행한다. ","date":"2019-07-17","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch4/:0:3","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 4장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch4/"},{"categories":["book","linux"],"content":"slab 메모리 영역 cat /proc/meminfo ... 생략 Slab: 473356 kB SReclaimable: 402036 kB SUnreclaim: 71320 kB ... 생략 slab: 메모리 영역 중 커널이 직접 사용하는 영역. 여기에는 dentry cache, inode cache 등 커널이 사용하는 메모리가 포함. SReclaimable: Slab 영역 중 재사용될 수 없는 영역. 캐시 용도로 사용하는 메모리들이 여기에 포함됨. 메모리 부족 현상 발생하면 해제(free)되어 프로세스에 할당이 가능한 영역 SUnreclaim: Slab 영역 중 재사용 될 수 없는 영역. 커널이 현재 사용중이며 해제해서 다른 용도로 쓸 수 없는 영역. Active / Total Objects (% used) : 1718090 / 1895312 (90.6%) Active / Total Slabs (% used) : 48101 / 48101 (100.0%) Active / Total Caches (% used) : 82 / 106 (77.4%) Active / Total Size (% used) : 435110.21K / 469842.19K (92.6%) Minimum / Average / Maximum Object : 0.01K / 0.25K / 12.75K OBJS ACTIVE USE OBJ SIZE SLABS OBJ/SLAB CACHE SIZE NAME 842205 743124 88% 0.10K 21595 39 86380K buffer_head 382368 368286 96% 0.19K 9104 42 72832K dentry 167216 167216 100% 0.94K 4919 34 157408K xfs_inode 115668 111428 96% 0.57K 4131 28 66096K radix_tree_node 55040 47535 86% 0.06K 860 64 3440K kmalloc-64 28176 28176 100% 0.16K 587 48 4696K xfs_ili 28152 28152 100% 0.12K 828 34 3312K kernfs_node_cache 26344 16899 64% 0.21K 712 37 5696K vm_area_struct 19278 10360 53% 0.19K 459 42 3672K kmalloc-192 16000 15514 96% 0.03K 125 128 500K kmalloc-32 15912 15912 100% 0.04K 156 102 624K selinux_inode_security ... 생략 buddy system : linux에서 메모리를 할당해주는 시스템. 가능한 적당하게 메모리 요청을 만족하도록 메모리를 여러 부분으로 나누는 메모리 할당 시스템. 메모리의 크기를 절반씩 분할하면서 가장 잘 맞는 크기의 메모리를 찾아 할당해 준다. 2의 거듭제곱 값으로 메모리를 할당. slab allocator : 버디 시스템을 통해 기본 페이지 크기인 4KB 영역을 할당 받은 후에 각각의 캐시 크기에 맞게 영역을 나눠서 사용. slab 영역은 free명령에서 used 영역에 포함된다. 커널이 사용하기 때문에 buffers/cached에 포함될거라 생각할 수 있지만, 실제로는 used에 포함됨. 출처 : DevOps와 SE를 위한 리눅스 커널 이야기 ","date":"2019-07-17","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch4/:0:4","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 4장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch4/"},{"categories":["book","linux"],"content":"3장 - Load average와 시스템 부하 ","date":"2019-07-13","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch3/:0:0","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 3장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch3/"},{"categories":["book","linux"],"content":"Load average의 정의 Load average는 R(run queue에서 cpu 사용을 위해 대기중인 프로세스들)과 D(네트워크/디스크 i/o 를 위해 wait queue 에서 대기중인 프로세스들)상태에 있는 프로세스 개수의 1분, 5분, 15분마다의 평균값이다. CPU 코어 갯수가 많으면 코어 갯수가 하나일 때 보다는 각 프로세스들이 여러개의 코어에 의해 더 빨리 처리될 수 있다. ","date":"2019-07-13","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch3/:0:1","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 3장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch3/"},{"categories":["book","linux"],"content":"Load average 계산 과정 root@August-PC:~# uptime 21:44:37 up 6 min, 0 users, load average: 0.52, 0.58, 0.59 root@August-PC:~# strace -s 65535 -f -t -o uptime_dump uptime 05:36:52 up 5:31, 0 users, load average: 0.52, 0.58, 0.59 /proc/loadavg -\u003e /fs/proc/loadavg.c에서 loadavg_proc_show() 함수 -\u003e /kernel/sched.c 에서 get_avenrun() 함수 -\u003e avenrun[] 배열 -\u003e calc_global_load() 함수 -\u003e calc_load_account_active() 함수 순으로 추적하다보면 nr_active 라는 변수에 nr_running + nr_uninterruptible 값들을 합하고 이를 1분, 5분, 15분 평균으로 나눠 계산하는 것을 확인할 수 있다. nr_running은 run queue에 있는 R상태의 프로세스들의 갯수이며, nr_uninterruptible은 wait queue에 있는 D상태의 프로세스들의 갯수이다. ","date":"2019-07-13","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch3/:0:2","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 3장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch3/"},{"categories":["book","linux"],"content":"CPU Bound vs I/O Bound 위에서 확인했듯 Load average는 cpu 사용을 기다리는 프로세스 갯수로만 계산되는 것이 아니라, 디스크/네트워크 I/O를 위해 대기중인 프로세스의 갯수도 계산에 포함된다. 즉, Load average가 높다는 것은 단순히 CPU를 사용하려는 프로세스가 많다는 의미가 아니고, I/O 병목이 생겨 I/O 작업을 대기하는 프로세스가 많을 수도 있다는 의미이다. 그러므로 Load average 숫자만 보고 시스템에 정확히 어떤 상태의 부하가 일어나고 있는지 파악하기가 어렵다. 그럼 부하의 종류를 어떻게 확인할까? ","date":"2019-07-13","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch3/:0:3","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 3장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch3/"},{"categories":["book","linux"],"content":"vmstat으로 부하의 정체 확인하기 [root@august-PC ~]# vmstat procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 2 0 1211796 143872 141040 5541164 0 0 15 19 0 0 26 3 69 1 0 r : The number of processes waiting for run time. 실행되기 위해 기다리는 프로세스 갯수(nr_running) b : The number of processes in uninterruptible sleep I/O를 위해 기다리는 프로세스 갯수(nr_uninterruptible) /proc/sched_debug 파일을 확인하면 각 CPU의 Run queue 상태와 스케줄링 정보를 살펴볼 수 있다. [root@august-PC ~]# cat /proc/sched_debug Sched Debug Version: v0.11, 3.10.0-862.6.3.el7.x86_64 #1 ktime : 31318815611.994170 sched_clk : 31318700701.301538 cpu_clk : 31318700701.301627 jiffies : 35613482909 ...중략 cpu#0, 2200.007 MHz .nr_running : 0 .load : 0 .nr_switches : 6296361526 .nr_load_updates : 15707632257 .nr_uninterruptible : 434324 .next_balance : 35613.482909 .curr-\u003epid : 0 .clock : 31318700701.633510 .cpu_load[0] : 0 .cpu_load[1] : 0 ...중략 runnable tasks: task PID tree-key switches prio wait-time sum-exec sum-sleep ---------------------------------------------------------------------------------------------------------- ksoftirqd/0 3 13546607321.808677 190671117 120 0.000000 1013193.525038 0.000000 0 / kworker/0:0H 5 544.548835 6 100 0.000000 0.029044 0.000000 0 / watchdog/0 12 -3.904516 7829709 0 0.000000 125610.812095 0.000000 0 / kdevtmpfs 51 1877281760.662029 185 120 0.000000 3.293578 0.000000 0 / kswapd0 70 13546604016.431647 923034 120 0.000000 894054.731239 0.000000 0 / scsi_eh_0 282 485.192906 2 120 0.000000 0.012182 0.000000 0 / kworker/0:1H 341 13546605978.612818 37669618 100 0.000000 601004.086434 0.000000 0 / su 4429 13546605952.403489 23 120 0.000000 33.713593 0.000000 0 / mysql 4582 13546606319.488393 5 120 0.000000 15.271120 0.000000 0 / sed 4708 13546607347.312431 2 120 0.000000 1.549732 0.000000 0 / ...생략 출처 : DevOps와 SE를 위한 리눅스 커널 이야기 ","date":"2019-07-13","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch3/:0:4","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 3장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch3/"},{"categories":["book","linux"],"content":"2장 - top을 통해 프로세스 정보 살펴보기 ","date":"2019-07-11","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch2/:0:0","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 2장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch2/"},{"categories":["book","linux"],"content":"top 명령어 실행 결과 root@August-PC:~# top -b -n 1 top - 01:57:36 up 58 min, 0 users, load average: 0.52, 0.58, 0.59 Tasks: 8 total, 1 running, 7 sleeping, 0 stopped, 0 zombie %Cpu(s): 9.0 us, 23.3 sy, 0.0 ni, 67.4 id, 0.0 wa, 0.3 hi, 0.0 si,KiB Mem : 8240388 total, 2032052 free, 5978984 used, 229352 buff/cKiB Swap: 25165824 total, 24837212 free, 328612 used. 2127672 avail PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ 1 root 20 0 8916 328 284 S 0.0 0.0 0:00.07 880 root 20 0 8916 228 176 S 0.0 0.0 0:00.01 881 august 20 0 18356 3764 3448 S 0.0 0.0 0:00.38 1074 root 20 0 8916 232 180 S 0.0 0.0 0:00.00 1075 august 20 0 18224 3492 3364 S 0.0 0.0 0:00.09 1087 root 20 0 16260 2116 2088 S 0.0 0.0 0:00.01 1088 root 20 0 18088 3392 3304 S 0.0 0.0 0:00.06 1104 root 20 0 18780 1888 1420 R 0.0 0.0 0:00.01 line 1: 현재 시스템의 시간과 uptime, 그리고 load average가 나온다 line 2: 현재 실행중인 process들 line 3: 리소스 사용량 통계 PID: process id, PR : Priority, NI : Nice value VIRT : VIRTual memory, 해당 프로세스에게 할당된 가상메모리 전체의 크기 RES: RESident memory, 해당 프로세스가 실제로 사용중인 물리메모리의 양 S : Process Status ","date":"2019-07-11","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch2/:0:1","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 2장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch2/"},{"categories":["book","linux"],"content":"Memory Commit 의 개념 커널은 프로세스가 메모리를 요청할 때 그에 맞는 크기를 가상으로 할당해준다. 실제로 요청받은 크기 전체만큼 물리메모리에 assign해주지는 않음. 그렇게 있다가 실제로 사용이 필요할 때마다 물리메모리를 조금씩 더 할당을 해줌(늘려줌). 이를 memory commit 이라고 한다. vm.overcommit_memory는 커널의 Memory commit 동작 방식을 변경할 수 있게 해주는 커널 파라미터. 0=최댓값 바탕으로 Memory commit, 1=무조건 overcommit, 2=vm.overcommit_ratio에 설정된 비율을 바탕으로 제한적으로 memory commit 커널 파라미터 보는법? sysctl root@August-PC:~# sysctl -a fs.binfmt_misc.status = enabled fs.binfmt_misc.WSLInterop = enabled fs.binfmt_misc.WSLInterop = interpreter /init ... ... vm.min_free_kbytes = 45056 vm.overcommit_memory = 0 vm.swappiness = 60 sysctl -a | grep pid_max 하면 현재 시스템의 생성 가능한 최대 pid 확인 가능 ","date":"2019-07-11","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch2/:0:2","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 2장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch2/"},{"categories":["book","linux"],"content":"프로세스 상태 Process Status 종류 : D, R, S, T, Z D = Uninterruptible sleep - 디스크, 네트워크 디바이스에 작업 요청 후 대기중인 상태(Run queue가 아닌 wait queue에 넣어놓음) R = Running - 현재 CPU에서 실행되고 있는 상태 S = Sleep - 그냥 자고있는 애들. D와의 차이는 요청한 리소스를 즉시 사용할 수 있는지 여부이다. T = traced or stopped. strace 등으로 프로세스가 추적되고 있는 상태 Z = zombie 상태. parent process가 죽은 child process를 의미 ","date":"2019-07-11","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch2/:0:3","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 2장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch2/"},{"categories":["book","linux"],"content":"프로세스 우선 순위 기본 PR값은 20이다. PR값에서 NI값을 뺀 값이 최종 우선순위가 된다. 숫자 0에 가까울수록 우선순위 높은것(뭔개소리죠??? 직접 해보면 안다…) nice -n N command 명령으로 해당 프로세스 nice 값을 부여해줄 수 있음.(N은 원하는 숫자) RT는 RealTime의 약자로써, RT 스케줄러에 의해 실시간으로 커널에 의해 처리되는 프로세스들임. CFQ(Completely Fair Queueing) 스케줄러보다 먼저 실행된다. 아 커널 소스 나와서 당황했다. 절대 만만치 않은 책인 듯 싶다. 출처 : DevOps와 SE를 위한 리눅스 커널 이야기 ","date":"2019-07-11","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch2/:0:4","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 2장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch2/"},{"categories":["book","linux"],"content":"1장 - 시스템 구성 정보 확인하기 ","date":"2019-06-22","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch1/:0:0","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 1장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch1/"},{"categories":["book","linux"],"content":"커널 정보 확인하기 uname -a # 커널 버전 확인dmesg #커널 디버그 메세지 cat /boot/config-`uname -r` | more # 커널 컴파일 옵션 확인 cat /boot/config-`uname -r` | grep -i config_function_tracer ftrace와 같은 커널 함수 레벨의 추적이 필요할 경우 CONFIG_FUNCTION_TRACER 같은 옵션이 커널 컴파일 옵션에 포함되어있어야 함 ","date":"2019-06-22","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch1/:0:1","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 1장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch1/"},{"categories":["book","linux"],"content":"CPU 정보 확인하기 dmidecode -t processor cat /proc/cpuinfo lscpu socket : number of CPU core : number of cores per CPU 시스템 최대 쓰레드 수 : # of socket * # of core * 2(Hyperthreading, Hyperthreading 지원 안할시 * 1) ","date":"2019-06-22","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch1/:0:2","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 1장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch1/"},{"categories":["book","linux"],"content":"Memory 정보 확인하기 dmidecode -t memory Physical memory array : 하나의 CPU socket에 함께 할당된 물리 메모리의 그룹 Memory device : 실제로 시스템에 꽂혀있는 메모리. ","date":"2019-06-22","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch1/:0:3","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 1장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch1/"},{"categories":["book","linux"],"content":"디스크 정보 확인하기 df -h smartctl -a /dev/sda smartctl -a /dev/sda -d cciss,0 # lsmod 를 통해 알아낸 현재 시스템 사용중인 raid 컨트롤러 드라이버를 명시 sda : scsi 방식 또는 sata, sas 방식 같은 일반적 디스크 hda : 개인용 컴퓨터용인 IDE 방식의 디스크 ","date":"2019-06-22","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch1/:0:4","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 1장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch1/"},{"categories":["book","linux"],"content":"네트워크 정보 확인하기 lspci | grep -i ether ethtool eth0 ethtool -g eth0 # Ring buffer의 크기를 확인 가능, 볼땐 -g, 설정할땐 -G 옵션 ethtool -k eth0 # 현재 NIC의 다양한 성능 최적화 옵션 확인, 마찬가지로 볼땐 소문자 -k, 설정할땐 -K ethtool -i eth0 # NIC의 커널 모듈 정보 표시 Ring buffer : 네트워크 카드의 버퍼 공간을 의미. 크기가 maximum으로 세팅 되어있지 않으면 네트워크 성능 저하 발생 가능 tcp-offload : MTU 이상의 크기를 가지는 패킷의 분할작업을 CPU 가 아닌 NIC가 직접 처리하여 CPU 성능 부담 줄이고 패킷 처리 성능 높임. 출처 : DevOps와 SE를 위한 리눅스 커널 이야기 ","date":"2019-06-22","objectID":"/2019/linux-kernel-story-for-devops-and-se-ch1/:0:5","tags":null,"title":"[요약]DevOps와 SE를 위한 리눅스 커널 이야기 1장","uri":"/2019/linux-kernel-story-for-devops-and-se-ch1/"},{"categories":["book"],"content":"2019년에 읽은 책들을 나열하는 포스트 아몬드(손원평) 사람의 아들(이문열) 지방 대사 켜는 스위치온 다이어트(박용우) 여행의 이유(김영하) 나는 왜 정치를 하는가(유승민) 히트 리프레시(Satya Nadella) 어느 애주가의 고백(Daniel Schreiber) 2019-06-17 더골(Eliyahu Moshe Goldratt) 2019-06-18 한국이 싫어서(장강명) 2019-06-18 인프라 엔지니어의 교과서: 시스템 구축과 관리편 2019-06-22 당선, 합격, 계급(장강명) 2019-06-30 소크라테스의 변론 크리톤 파이돈 향연(Plato) 2019-07-04 Hello Coding 알고리즘(Aditya Y. Bhargava) 2019-07-07 개발자도 궁금한 IT 인프라(정송화, 김영선, 전성민) 2019-07-09 서른의 반격(손원평) 2019-07-12 산 자들(장강명) 2019-07-15 지극히 사적인 초능력(장강명) 2019-07-19 멋진 신세계(Aldous Leonard Huxley) 2019-07-20 인간 실격(다자이 오사무) 2019-08-01 함께 자라기(김창준) 2019-08-04 바닷가 작업실에서는 전혀 다른 시간이 흐른다(김정운) 2019-08-05 열광금지, 에바로드(장강명) 2019년 독서는 8월에서 끝이 났다… ","date":"2019-06-09","objectID":"/2019/2019-books-i-read/:0:0","tags":null,"title":"2019 Books I Read","uri":"/2019/2019-books-i-read/"},{"categories":["git"],"content":"How to git pull with submodules of repo.","date":"2019-06-03","objectID":"/2019/how-to-git-pull-with-submodules/","tags":null,"title":"How to Git Pull With Submodules","uri":"/2019/how-to-git-pull-with-submodules/"},{"categories":["git"],"content":"집 데탑에만 블로그 소스가 있는지라 회사 컴에서도 작성할 수 있게끔 내 블로그 repo를 clone하였다. 근데 그냥 clone을 하니 submodule로 등록한 repo는 같이 clone이 안되더라. 구글링을 좀 해본 결과 링크와 같이 git submodule update --init --recursive clone 이후에 해당 repo의 root에서 위 명령어를 통해 submodule을 업데이트 해주니 해결이 되었다. ","date":"2019-06-03","objectID":"/2019/how-to-git-pull-with-submodules/:0:0","tags":null,"title":"How to Git Pull With Submodules","uri":"/2019/how-to-git-pull-with-submodules/"},{"categories":null,"content":"Welcome to my blog. I am currently working as System engineer. ","date":"2019-06-02","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["blog"],"content":"This is an first post of my blog.","date":"2019-06-02","objectID":"/2019/first-post/","tags":null,"title":"First Post","uri":"/2019/first-post/"},{"categories":["blog"],"content":"I just created my first blog :D ","date":"2019-06-02","objectID":"/2019/first-post/:0:0","tags":null,"title":"First Post","uri":"/2019/first-post/"}]